<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>haskell-101</title>
<!-- 2015-05-05 Tue 11:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Michael A. King" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<style type="text/css">
 pre.src {background-color: black; color: white;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">haskell-101</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Haskell 101</a>
<ul>
<li><a href="#sec-1-1">1.1. Data Representation in Haskell</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. Primitive Data Types</a></li>
<li><a href="#sec-1-1-2">1.1.2. Haskell Data Structures</a></li>
<li><a href="#sec-1-1-3">1.1.3. Defining New Data Types</a></li>
<li><a href="#sec-1-1-4">1.1.4. Record Syntax</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. Functions in Haskell</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. Pattern matching</a></li>
<li><a href="#sec-1-2-2">1.2.2. Guards</a></li>
<li><a href="#sec-1-2-3">1.2.3. Where clause</a></li>
<li><a href="#sec-1-2-4">1.2.4. Let expressions</a></li>
<li><a href="#sec-1-2-5">1.2.5. Case expressions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Haskell 101</h2>
<div class="outline-text-2" id="text-1">
<p>
Haskell is a computer programming language. In particular, it is a 
polymorphically statically typed, lazy, purely functional language, quite 
different from most other programming languages. The language is named for 
Haskell Brooks Curry, whose work in mathematical logic serves as a foundation for
functional languages. Haskell is based on lambda calculus, hence the lambda 
used as a logo.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Data Representation in Haskell</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Data is how we store information and model problems, which makes it integral to
any good programming language.  Haskell is a functional language that does not
incorporate the Object Oriented Paradigm (OOP) most programmers are familiar
with coming out of college. However, much of the primitive data types in Haskell
maps one-to-one with what you will be familiar with coming from an imperative
background.
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Primitive Data Types</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
<span class="underline">Int</span> stands for integer. It's used for whole numbers.
</p>

<p>
<span class="underline">Integer</span> stands for, er â€¦ also integer. The main difference is that it's not 
bounded so it can be used to represent really really big numbers. I mean like 
really big. Int, however, is more efficient.
</p>

<p>
<span class="underline">Float</span> is a real floating point with single precision.
</p>

<p>
<span class="underline">Double</span> is a real floating point with double the precision!
</p>

<p>
<span class="underline">Bool</span> is a boolean type. It can have only two values: <b>True</b> and <b>False</b>.
</p>

<p>
<span class="underline">Char</span> represents a character. It's denoted by single quotes. A list of 
characters is a string.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Haskell Data Structures</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
<span class="underline">Lists</span>
Lists are a very powerful data in Haskell and as such, are one of the most used
data structures.  Lists are to Haskell what dictionaries are to Python. 
</p>

<p>
In Haskell, lists are a homogenous data structure. It stores several elements of
the same type. That means that we can have a list of integers or a list of 
characters but we can't have a list that has a few integers and then a few 
characters.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-1"><span style="color: #8ac6f2; font-weight: bold;">let</span> mynumbers <span style="color: #cae682;">=</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5]
</pre>
</div>

<pre class="example">
[1,2,3,4,5]
</pre>

<p>
Concatenating a list&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-3">[1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5] <span style="color: #cae682;">++</span> [6<span style="color: #cae682;">,</span> 7]
</pre>
</div>

<pre class="example">
[1,2,3,4,5,6,7]
</pre>

<p>
Prepending a list&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-4">0 <span style="color: #92a65e; font-weight: bold;">:</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5]
</pre>
</div>

<pre class="example">
[0,1,2,3,4,5]
</pre>

<p>
Index a list&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-5">[1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5] <span style="color: #cae682;">!!</span> 3
</pre>
</div>

<pre class="example">
4
</pre>

<p>
List ranges provide a concise syntax for creating a list of sequetial values.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-6">[1 <span style="color: #cae682;">..</span> 6]
</pre>
</div>

<pre class="example">
[1,2,3,4,5,6]
</pre>

<p>
Here are four basic functions that operate on lists (head, tail, last,
init).
</p>

<p>
<b>head</b> takes a list and returns its head. The head of a list is basically its
first element.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-7"><span style="color: #cae682;">head</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5<span style="color: #cae682;">,</span> 6]
</pre>
</div>

<pre class="example">
1
</pre>

<p>
<b>tail</b> takes a list and returns its tail. In other words, it chops off a list's head.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-8"><span style="color: #cae682;">tail</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5<span style="color: #cae682;">,</span> 6]
</pre>
</div>

<pre class="example">
[2,3,4,5,6]
</pre>

<p>
<b>last</b> takes a list and returns its last element.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-9"><span style="color: #cae682;">last</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5<span style="color: #cae682;">,</span> 6]
</pre>
</div>

<pre class="example">
6
</pre>

<p>
<b>init</b> takes a list and returns everything except its last element.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-10"><span style="color: #cae682;">init</span> [1<span style="color: #cae682;">,</span> 2<span style="color: #cae682;">,</span> 3<span style="color: #cae682;">,</span> 4<span style="color: #cae682;">,</span> 5<span style="color: #cae682;">,</span> 6]
</pre>
</div>

<pre class="example">
[1,2,3,4,5]
</pre>

<p>
<span class="underline">Tuples</span>
In some ways, tuples are like lists â€” they are a way to store several values
into a single value. However, there are a few fundamental differences. For
example, it doesn't matter if a list has only one number in it or an infinite 
amount of numbers. Tuples, however, are used when you know exactly how many 
values you want to combine and its type depends on how many components it has 
and the types of the components.
</p>

<p>
Another key difference is that they don't have to be homogenous. Unlike a list,
a tuple can contain a combination of several types.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-11"><span style="color: #8ac6f2; font-weight: bold;">let</span> mytuple <span style="color: #cae682;">=</span> (<span style="color: #95e454;">"wow"</span><span style="color: #cae682;">,</span> 5)
</pre>
</div>

<pre class="example">
(\"wow\",5)
</pre>

<p>
Functions to access the first and second element in a tuple.
</p>

<p>
<b>fst</b> access the first element in a tuple
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-13"><span style="color: #cae682;">fst</span> (<span style="color: #95e454;">"Hello"</span><span style="color: #cae682;">,</span> <span style="color: #95e454;">"World!"</span>)
</pre>
</div>

<pre class="example">
Hello
</pre>

<p>
<b>snd</b> access the second element in a tuple
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-14"><span style="color: #cae682;">snd</span> (<span style="color: #95e454;">"Hello"</span><span style="color: #cae682;">,</span> <span style="color: #95e454;">"World!"</span>)
</pre>
</div>

<pre class="example">
World!
</pre>

<p>
A cool function that produces a list of pairs: <b>zip</b>. It takes two lists and then
zips them together into one list by joining the matching elements into pairs.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-15"><span style="color: #cae682;">zip</span> [1<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>4] [<span style="color: #95e454;">"one"</span><span style="color: #cae682;">,</span> <span style="color: #95e454;">"two"</span><span style="color: #cae682;">,</span> <span style="color: #95e454;">"three"</span><span style="color: #cae682;">,</span> <span style="color: #95e454;">"four"</span>]
</pre>
</div>

<pre class="example">
[(1,"one"),(2,"two"),(3,"three"),(4,"four")]
</pre>

<p>
Here is an example of the power and elegance of the list data structure in
Haskell.  In this example you could imagine data coming coming from different
locations to populate each list.  Then we can simply use functions to transform
the data into a form that can be visualized.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="HaskellDataStructures-example-16">show <span style="color: #cae682;">$</span> transpose [ [0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>5<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>4<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>3<span style="color: #cae682;">,</span>1<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>2<span style="color: #cae682;">,</span>0]<span style="color: #cae682;">,</span> [0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0<span style="color: #cae682;">,</span>0] ]
</pre>
</div>

<pre class="example">
[[0,0,0,0,0,0,0],[0,2,2,2,0,2,0],[0,0,3,3,3,2,0],[0,2,2,4,3,2,0],[3,2,3,3,1,2,0],[0,2,5,2,2,2,0],[0,0,0,0,0,0,0]]
</pre>

<p>
This transformed list can be fed to gnuplot in order to generate a visualization
that makes sense for the data.  I just picked it because it looked cool!
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">0</td>
<td class="right">2</td>
<td class="right">2</td>
<td class="right">2</td>
<td class="right">0</td>
<td class="right">2</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">3</td>
<td class="right">3</td>
<td class="right">3</td>
<td class="right">2</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">0</td>
<td class="right">2</td>
<td class="right">2</td>
<td class="right">4</td>
<td class="right">3</td>
<td class="right">2</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">3</td>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">3</td>
<td class="right">1</td>
<td class="right">2</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">0</td>
<td class="right">2</td>
<td class="right">5</td>
<td class="right">2</td>
<td class="right">2</td>
<td class="right">2</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
<td class="right">0</td>
</tr>
</tbody>
</table>


<div class="figure">
<p><img src="./images/gnuplot.png" alt="gnuplot.png" />
</p>
<p><span class="figure-number">Figure 1:</span> GNUPlot rendering of the transformed list data</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> Defining New Data Types</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Haskell has a number of basic built-in types (Bool, Int, Char, Float). As with 
any language, however, you can make your own user-defined custom types. In
haskell, instead of objects, we use Algebraic Data Types.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="AlgebraicDataTypes-example-1"><span style="color: #8ac6f2; font-weight: bold;">data</span> <span style="color: #92a65e; font-weight: bold;">Bool</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">False</span> <span style="color: #cae682;">|</span> <span style="color: #92a65e; font-weight: bold;">True</span>
</pre>
</div>

<p>
The part preceeding the "=" denotes the type, which in the above case is Bool.
The parts following the "=" are the value constructors.
</p>

<p>
Using the typical shape example from OOP that we all know and love&#x2026;
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="AlgebraicDataTypes-example-2"><span style="color: #8ac6f2; font-weight: bold;">data</span> <span style="color: #92a65e; font-weight: bold;">Shape</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Circle</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #cae682;">|</span> <span style="color: #92a65e; font-weight: bold;">Rectangle</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
</pre>
</div>

<p>
In this example the type is Shape and the value constructors are Circle and
Rectangle.  So we are saying that a Shape can either be a Circle or a
Rectangle.  In the case of the Circle value constructor, it takes three values,
the x and y values that compose the coordinates of the center of the circle, and
the radius.  In the case of the Rectangle, the first two values are the
coordinates of its upper-left corder, and the second two coordinates are
lower-right corner.
</p>

<p>
Here is an example of a function called 'area' that will take a Shape and return
its area.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="AlgebraicDataTypes-example-3"><span style="color: #cae682;">area</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Shape</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span>
<span style="color: #cae682;">area</span> (<span style="color: #92a65e; font-weight: bold;">Circle</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> r) <span style="color: #cae682;">=</span> 3<span style="color: #cae682;">.</span>14 <span style="color: #cae682;">*</span> r <span style="color: #cae682;">^</span> 2
<span style="color: #cae682;">area</span> (<span style="color: #92a65e; font-weight: bold;">Rectangle</span> x1 y1 x2 y2) <span style="color: #cae682;">=</span> (abs <span style="color: #cae682;">$</span> x2 <span style="color: #cae682;">-</span> x1) <span style="color: #cae682;">*</span> (abs <span style="color: #cae682;">$</span> y2 <span style="color: #cae682;">-</span> y1)
</pre>
</div>

<p>
Here are some examples of how to use the 'area' function.
</p>

<p>
Calling 'area' with a 'Circle' value constructor:
</p>
<div class="org-src-container">

<pre class="src src-haskell" id="AlgebraicDataTypes-example-4">putStrLn <span style="color: #cae682;">$</span> <span style="color: #95e454;">"Circle Area: "</span> <span style="color: #cae682;">++</span> show (area (<span style="color: #92a65e; font-weight: bold;">Circle</span> 10 20 10))
</pre>
</div>

<pre class="example">
Circle Area: 314.0
</pre>

<p>
Calling 'area' with a 'Rectangle' value constructor:
</p>
<div class="org-src-container">

<pre class="src src-haskell" id="AlgebraicDataTypes-example-5">putStrLn <span style="color: #cae682;">$</span> <span style="color: #95e454;">"Rectangle Area: "</span> <span style="color: #cae682;">++</span> show (area (<span style="color: #92a65e; font-weight: bold;">Rectangle</span> 0 0 100 100))
</pre>
</div>

<pre class="example">
Rectangle Area: 10000.0      
</pre>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> Record Syntax</h4>
<div class="outline-text-4" id="text-1-1-4">
<p>
Record syntax allows us to have the compiler generate function getters for our 
user defined types.  We could certainly use pattern matching to access the 
specific values in a value constructor or even write getters ourselves. However, 
this is not desireable as it can be very tedious and syntactically obtuse&#x2026;we 
aren't writing Java code for goodness sake!
</p>

<p>
Consider the following data representing a person in a contact list.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-1"><span style="color: #8ac6f2; font-weight: bold;">data</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #92a65e; font-weight: bold;">Int</span> <span style="color: #92a65e; font-weight: bold;">Float</span> <span style="color: #92a65e; font-weight: bold;">String</span> <span style="color: #8ac6f2; font-weight: bold;">deriving</span> (<span style="color: #92a65e; font-weight: bold;">Show</span>)
</pre>
</div>

<p>
The fields in the Person value constructor are first name, last name, age, height,
and phone number repectively.  Let's construct a Person.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-2"><span style="color: #8ac6f2; font-weight: bold;">let</span> contact <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #95e454;">"Michael"</span> <span style="color: #95e454;">"Bolton"</span> 105 4 <span style="color: #95e454;">"555-345-6784"</span>
<span style="color: #cae682;">show</span> contact
</pre>
</div>

<pre class="example">
Person \"Michael\" \"Bolton\" 105 4.0 \"555-345-6784\"
</pre>

<p>
What if we want to create a function to get seperate info from a person? A 
function that gets some person's first name, a function that gets some person's 
last name, etc. Well, we'd have to define them kind of like this.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-3"><span style="color: #cae682;">firstName</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">firstName</span> (<span style="color: #92a65e; font-weight: bold;">Person</span> firstname <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span>) <span style="color: #cae682;">=</span> firstname  
  
<span style="color: #cae682;">lastName</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">lastName</span> (<span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> lastname <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span>) <span style="color: #cae682;">=</span> lastname  
  
<span style="color: #cae682;">age</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Int</span>  
<span style="color: #cae682;">age</span> (<span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> age <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span>) <span style="color: #cae682;">=</span> age  
  
<span style="color: #cae682;">height</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">Float</span>  
<span style="color: #cae682;">height</span> (<span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> height <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span>) <span style="color: #cae682;">=</span> height  
  
<span style="color: #cae682;">phoneNumber</span> <span style="color: #cae682;">::</span> <span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">phoneNumber</span> (<span style="color: #92a65e; font-weight: bold;">Person</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> <span style="color: #8ac6f2; font-weight: bold;">_</span> number <span style="color: #8ac6f2; font-weight: bold;">_</span>) <span style="color: #cae682;">=</span> number
</pre>
</div>

<p>
That is a lot of work for what amounts to boilerplate code.  But it does work. 
Here they are in action.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-4"><span style="color: #cae682;">firstName</span>   contact
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-4"><span style="color: #cae682;">lastName</span>    contact
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-4"><span style="color: #cae682;">age</span>         contact
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-4"><span style="color: #cae682;">height</span>      contact
</pre>
</div>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-4"><span style="color: #cae682;">phoneNumber</span> contact
</pre>
</div>

<pre class="example">
Michael
Bolton
105
4.0
555-345-6784
</pre>

<p>
Enter Record Syntax.  All the boilerplate code above an be generated using
record syntax, making our code much simpler.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-5"><span style="color: #8ac6f2; font-weight: bold;">data</span> <span style="color: #92a65e; font-weight: bold;">Car</span> <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Car</span> { make <span style="color: #92a65e; font-weight: bold;">::</span> <span style="color: #92a65e; font-weight: bold;">String</span><span style="color: #cae682;">,</span> model <span style="color: #92a65e; font-weight: bold;">::</span> <span style="color: #92a65e; font-weight: bold;">String</span><span style="color: #cae682;">,</span> color <span style="color: #92a65e; font-weight: bold;">::</span> <span style="color: #92a65e; font-weight: bold;">String</span> } <span style="color: #8ac6f2; font-weight: bold;">deriving</span> (<span style="color: #92a65e; font-weight: bold;">Show</span>)
</pre>
</div>

<p>
Now we can define our algebraic data types and all of our accessor functions 
once in a single place.
</p>

<p>
An added benefit of using record syntax is that we can now use named arguments
when constructing a new value.
</p>

<div class="org-src-container">

<pre class="src src-haskell" id="RecordSyntax-example-6"><span style="color: #8ac6f2; font-weight: bold;">let</span> newCar <span style="color: #cae682;">=</span> <span style="color: #92a65e; font-weight: bold;">Car</span> {make<span style="color: #cae682;">=</span><span style="color: #95e454;">"Dodge"</span><span style="color: #cae682;">,</span>model<span style="color: #cae682;">=</span><span style="color: #95e454;">"Ram Charger"</span><span style="color: #cae682;">,</span>color<span style="color: #cae682;">=</span><span style="color: #95e454;">"555-645-8907"</span>}
</pre>
</div>

<pre class="example">
Car {make = \"Dodge\", model = \"Ram Charger\", color = \"555-645-8907\"}
</pre>

<p>
When making a new person, we don't have to necessarily put the fields in the 
proper order, as long as we list all of them. But if we don't use record syntax,
we have to specify them in order.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Functions in Haskell</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Functions are defined as a series of expressions in Haskell. That means that
when you define a function, it can look like it has multiple function bodies,
but only one will be chosen depending on the arguments passed to the function.
</p>
</div>

<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> Pattern matching</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
Pattern matching consists of specifying patterns to which some data should
conform and then checking to see if it does and deconstructing the data
according to those patterns.
</p>

<p>
When defining functions, you can define separate function bodies for different
patterns. This leads to really neat code that's simple and readable. 
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">lucky</span> <span style="color: #cae682;">::</span> (<span style="color: #92a65e; font-weight: bold;">Integral</span> a) <span style="color: #cae682;">=&gt;</span> a <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">lucky</span> 7 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"LUCKY NUMBER SEVEN!"</span>  
<span style="color: #cae682;">lucky</span> x <span style="color: #cae682;">=</span> <span style="color: #95e454;">"Sorry, you're out of luck, pal!"</span>
</pre>
</div>

<p>
In the example above, you can see that if we call 'lucky' with the number 7, the
output will be a string that says "LUCKY NUMBER SEVEN!".  Otherwise, the
function will print out "Sorry, you're out of luck, pal!".  Patterns are matched
starting from the top and working their way down.  
</p>

<p>
If the two expressions for the definition of 'lucky' were swapped, the string
"LUCKY NUMBER SEVEN!" would never be printed.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> Guards</h4>
<div class="outline-text-4" id="text-1-2-2">
<p>
Whereas patterns are a way of making sure a value conforms to some form and
deconstructing it, guards are a way of testing whether some property of a value
(or several of them) are true or false.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">bmiTell</span> <span style="color: #cae682;">::</span> (<span style="color: #92a65e; font-weight: bold;">RealFloat</span> a) <span style="color: #cae682;">=&gt;</span> a <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">bmiTell</span> bmi  
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 18<span style="color: #cae682;">.</span>5 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're underweight, you emo, you!"</span>                   <span style="color: #cae682;">|</span>
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 25<span style="color: #cae682;">.</span>0 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're supposedly normal. Pffft, I bet you're ugly!"</span> <span style="color: #cae682;">|</span>
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 30<span style="color: #cae682;">.</span>0 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're fat! Lose some weight, fatty!"</span>                <span style="color: #cae682;">|</span>
    <span style="color: #cae682;">|</span> otherwise   <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're a whale, congratulations!"</span>
</pre>
</div>

<p>
In the above example we are checking the value of the paramer 'bmi' and
selecting an appropriate function expression based on the result.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> Where clause</h4>
<div class="outline-text-4" id="text-1-2-3">
<p>
Where clauses allow us to assign names to funtions and variables used in the
expression of a function body.  This can greatly increase readability as well
reduce the amount of code we have to write.  In addition, it can reduce the
number of calculations needed at runtime.  Se the example below.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">bmiTell</span> <span style="color: #cae682;">::</span> (<span style="color: #92a65e; font-weight: bold;">RealFloat</span> a) <span style="color: #cae682;">=&gt;</span> a <span style="color: #cae682;">-&gt;</span> a <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">bmiTell</span> weight height  
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 18<span style="color: #cae682;">.</span>5 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're underweight, you emo, you!"</span>  
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 25<span style="color: #cae682;">.</span>0 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're supposedly normal. Pffft, I bet you're ugly!"</span>  
    <span style="color: #cae682;">|</span> bmi <span style="color: #cae682;">&lt;=</span> 30<span style="color: #cae682;">.</span>0 <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're fat! Lose some weight, fatty!"</span>  
    <span style="color: #cae682;">|</span> otherwise   <span style="color: #cae682;">=</span> <span style="color: #95e454;">"You're a whale, congratulations!"</span>  
    <span style="color: #8ac6f2; font-weight: bold;">where</span> bmi <span style="color: #cae682;">=</span> weight <span style="color: #cae682;">/</span> height <span style="color: #cae682;">^</span> 2
</pre>
</div>

<p>
The names we define in the where section of a function are only visible to that
function, so we don't have to worry about them polluting the namespace of other
functions. Notice that all the names are aligned at a single column. If we don't
align them nice and proper, Haskell gets confused because then it doesn't know
they're all part of the same block.
</p>

<p>
<b>where</b> bindings aren't shared across function bodies of different patterns. If
you want several patterns of one function to access some shared name, you have
to define it globally.
</p>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> Let expressions</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
Very similar to <b>where</b> bindings are <b>let</b> bindings. Where bindings are a syntactic
construct that let you bind to variables at the end of a function and the whole
function can see them, including all the guards. Let bindings let you bind to
variables anywhere and are expressions themselves, but are very local, so they
don't span across guards. 
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">cylinder</span> <span style="color: #cae682;">::</span> (<span style="color: #92a65e; font-weight: bold;">RealFloat</span> a) <span style="color: #cae682;">=&gt;</span> a <span style="color: #cae682;">-&gt;</span> a <span style="color: #cae682;">-&gt;</span> a  
<span style="color: #cae682;">cylinder</span> r h <span style="color: #cae682;">=</span> 
    <span style="color: #8ac6f2; font-weight: bold;">let</span> sideArea <span style="color: #cae682;">=</span> 2 <span style="color: #cae682;">*</span> pi <span style="color: #cae682;">*</span> r <span style="color: #cae682;">*</span> h  
        topArea <span style="color: #cae682;">=</span> pi <span style="color: #cae682;">*</span> r <span style="color: #cae682;">^</span>2  
    <span style="color: #8ac6f2; font-weight: bold;">in</span>  sideArea <span style="color: #cae682;">+</span> 2 <span style="color: #cae682;">*</span> topArea
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> Case expressions</h4>
<div class="outline-text-4" id="text-1-2-5">
<p>
<b>case</b> expressions are, well, expressions, much like if else expressions and let
bindings. Not only can we evaluate expressions based on the possible cases of
the value of a variable, we can also do pattern matching.
</p>

<div class="org-src-container">

<pre class="src src-haskell"><span style="color: #cae682;">describeList</span> <span style="color: #cae682;">::</span> [a] <span style="color: #cae682;">-&gt;</span> <span style="color: #92a65e; font-weight: bold;">String</span>  
<span style="color: #cae682;">describeList</span> xs <span style="color: #cae682;">=</span> <span style="color: #95e454;">"The list is "</span> <span style="color: #cae682;">++</span> 
                      <span style="color: #8ac6f2; font-weight: bold;">case</span> xs <span style="color: #8ac6f2; font-weight: bold;">of</span> 
                           <span style="color: #92a65e; font-weight: bold;">[]</span> <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"empty."</span>  
                           [x] <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"a singleton list."</span>   
                           xs <span style="color: #cae682;">-&gt;</span> <span style="color: #95e454;">"a longer list."</span>
</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Michael A. King</p>
<p class="date">Created: 2015-05-05 Tue 11:16</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
